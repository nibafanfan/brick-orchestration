import os
import openai
import requests
import yaml
from bs4 import BeautifulSoup
from jinja2 import Environment, FileSystemLoader
from pathlib import Path

# â”€â”€â”€â”€â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€
MARK = "<!-- AUTOâ€‘GENERATEDâ€‘READMEâ€‘START -->"
BRICKS_DIR = Path("brick_repos")
TEMPLATE_DIR = Path("templates")
TEMPLATE_FN = "readme_template.j2"

openai.api_key = os.environ.get("OPENAI_API_KEY")

# â”€â”€â”€â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€
def load_meta(meta_path):
    with open(meta_path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)

def render_readme(meta, gpt_summary, env):
    tmpl = env.get_template(TEMPLATE_FN)
    first_src = meta.get("source", [""])[0] if isinstance(meta.get("source"), list) else meta.get("source")
    context = {**meta, "src": first_src, "gpt_summary": gpt_summary}
    return tmpl.render(**context)

def extract_manual_readme(readme_path):
    if readme_path.exists():
        text = readme_path.read_text(encoding="utf-8")
        return text.split(MARK, 1)[0].strip()
    return ""

def gpt_summarize(manual_text):
    if not manual_text.strip():
        return ""
    messages = [
        {"role": "system", "content": "You are a scientific writing assistant helping to summarize dataset documentation into short, accurate overviews."},
        {"role": "user", "content": f"Summarize this README for a BioBrick repo. Keep it accurate and concise:\n\n{manual_text}"}
    ]
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=messages,
        temperature=0.5
    )
    print("ğŸ“¤ Prompt to GPT:\n", manual_text)
    print("ğŸ“¥ GPT Summary:\n", response.choices[0].message.content.strip())
    return response.choices[0].message.content.strip()

def process_brick(brick_name, env):
    brick_path = BRICKS_DIR / brick_name
    meta_path = brick_path / "meta.yaml"
    readme_path = brick_path / "README.md"

    if not meta_path.exists():
        print(f"âš ï¸  {brick_name}: meta.yaml not found â€” skipped")
        return

    try:
        meta = load_meta(meta_path)
    except yaml.YAMLError as e:
        print(f"âŒ  {brick_name}: invalid YAML â€” {e}")
        return

    manual_section = extract_manual_readme(readme_path)
    gpt_summary = gpt_summarize(manual_section)
    autogenerated = MARK + "\n" + render_readme(meta, gpt_summary, env)

    combined = manual_section + "\n\n" + autogenerated if manual_section else autogenerated
    readme_path.write_text(combined, encoding="utf-8")
    print(f"âœ…  {brick_name}: README.md updated with GPT summary")

def main():
    from argparse import ArgumentParser
    parser = ArgumentParser()
    parser.add_argument("--brick", help="Generate README for a specific brick")
    args = parser.parse_args()

    env = Environment(
        loader=FileSystemLoader(TEMPLATE_DIR),
        autoescape=True,
        trim_blocks=True,
        lstrip_blocks=True
    )

    if args.brick:
        process_brick(args.brick, env)
    else:
        for brick in sorted(BRICKS_DIR.iterdir()):
            if brick.is_dir():
                process_brick(brick.name, env)

if __name__ == "__main__":
    main()
