#!/usr/bin/env python3
"""
generate_readmes.py
───────────────────
Injects (or refreshes) the auto-generated README block under a
consistent marker.

• Manual section above the marker is left untouched.
• Auto section is rendered from Jinja template `templates/readme_template.j2`.
• Duplicate top-level headings are removed.
• Handles both ASCII "-" and any Unicode hyphen that might already
  exist in an older marker.
"""

import re
import yaml
from pathlib import Path
from argparse import ArgumentParser
from jinja2 import Environment, FileSystemLoader

# ────────────────────────────────────────────────────────────────
MARK_CANON = "<!-- AUTO-GENERATED-README-START -->"
# matches any of  U+002D -  U+2010 … U+2015
MARK_RE = re.compile(
    r"<!--\s*AUTO[\u002D\u2010-\u2015]GENERATED[\u002D\u2010-\u2015]"
    r"README[\u002D\u2010-\u2015]START\s*-->",
    flags=re.IGNORECASE,
)

BRICKS_DIR   = Path(__file__).resolve().parents[1] / "brick_repos"
TEMPLATE_DIR = Path(__file__).resolve().parents[1] / "templates"
TEMPLATE_FN  = "readme_template.j2"
# ────────────────────────────────────────────────────────────────


def load_meta(meta_path: Path) -> dict:
    with meta_path.open(encoding="utf-8") as fh:
        return yaml.safe_load(fh)


def render_auto_section(meta: dict, env: Environment) -> str:
    tmpl = env.get_template(TEMPLATE_FN)
    first_src = (
        meta["source"][0] if isinstance(meta.get("source"), list) else meta.get("source")
    )
    md = tmpl.render(**meta, src=first_src)

    # Remove duplicate H1 (# chembl) if present ------------------
    lines = md.lstrip().splitlines()
    if lines and lines[0].startswith("#"):
        wanted = (meta.get("title") or "UNTITLED").strip().lower()
        heading = lines[0].lstrip("#").strip().lower()
        if heading == wanted:
            md = "\n".join(lines[1:]).lstrip()
    # ------------------------------------------------------------
    return md


def generate_for_brick(brick_name: str, env: Environment, *, force: bool = False) -> None:
    brick_path  = BRICKS_DIR / brick_name
    meta_path   = brick_path / "meta.yaml"
    readme_path = brick_path / "README.md"

    if not meta_path.exists():
        print(f"⚠️  {brick_name}: meta.yaml not found – skipped")
        return

    try:
        meta = load_meta(meta_path)
    except yaml.YAMLError as exc:
        print(f"❌  {brick_name}: invalid YAML – {exc}")
        return

    auto_md = render_auto_section(meta, env)
    autogenerated_block = f"{MARK_CANON}\n{auto_md}"

    if readme_path.exists():
        original = readme_path.read_text(encoding="utf-8")
        match = MARK_RE.search(original)
        manual_section = original[: match.start()] if match else original
        manual_section = manual_section.rstrip()

        new_readme = f"{manual_section}\n\n{autogenerated_block}"
        readme_path.write_text(new_readme, encoding="utf-8")
        print(f"✅  {brick_name}: README.md updated (auto block replaced)")
    elif force:
        header = f"# {brick_name}\n"
        new_readme = f"{header}\n\n{autogenerated_block}"
        readme_path.write_text(new_readme, encoding="utf-8")
        print(f"🆕  {brick_name}: README.md created")
    else:
        print(
            f"📝  {brick_name}: no README.md found — run with --force to create one"
        )


def main() -> None:
    parser = ArgumentParser()
    parser.add_argument("--brick", help="Generate README for a single brick")
    parser.add_argument(
        "--force",
        action="store_true",
        help="Create README if missing; overwrite auto block unconditionally",
    )
    args = parser.parse_args()

    env = Environment(
        loader=FileSystemLoader(TEMPLATE_DIR),
        autoescape=True,
        trim_blocks=True,
        lstrip_blocks=True,
    )

    if args.brick:
        generate_for_brick(args.brick, env, force=args.force)
    else:
        for brick_dir in sorted(BRICKS_DIR.iterdir()):
            if brick_dir.is_dir():
                generate_for_brick(brick_dir.name, env, force=args.force)


if __name__ == "__main__":
    main()
